\documentclass{article}

\usepackage{hyperref}
\title{Quarto + : Rendu de la premi\`ere partie du projet}
\author{Nicolas Devatine et Julien Guyot}
\date{Lundi 5 Mars 2016}
\begin{document}
\maketitle
% 4bits pour mod\'eliser une case + un int16 pour dire quelles cases
% sont prises. 
% Du coup, on peut mod\'eliser le plateau par un int64. 
% Chaque ``bout'' de 4 bits est une case donn\'ee
\section{Question 1}

%Note : il faudrait ajouter un byte pour savoir quelle pi\`ece doit \^etre pos\'ee

Note : Cette r\'eponse est bien plus longue que ce qui est a priori
demand\'e, n\'eanmoins nous avons fait le choix de la laisser, afin d'\^etre
le plus clair possible, sur les ``pourquoi'' et ``comment ?'' de ce
projet d'impl\'ementation.


Il y a n\'eanmoins un bref r\'esum\'e de la r\'eponse
\hyperlink{resume}{ici}
si vous pr\'ef\'erez ne pas tout lire.


Nous avons pris le parti de la performance : Utiliser des types/classes,
ainsi que des op\'erateurs les plus simples possible --- Du point de vue machine
---  afin que les
performances soient les meilleures possible.


\subsection{Mod\'elisation du plateau :}
Il y a seize pi\`eces, donc ``l'identifiant'' de chaque pi\`ece peut \^etre
cod\'e sur 4 bits. \\
Il y a 16 cases, donc on peut modliser un plateau comme un long (de
16*4 = 64 bits), que nous appellerons ``plateau''.\\
Nous aurons aussi deux short (16b): Le premier, ``S'' donne les cases qui sont occup\'ees par
une pi\`ece, et enfin l'autre
donne les pi\`eces qui ont d\'ej\`a \'et\'e pos\'ees ``P''. \\
Nous aurons aussi un byte (8b), qu'on appellera ``B'', qui donne le
stade du tour dans lequel on est (i.e ``quel joueur joue quel type de
coup?''), et la
pi\`ece qu'il faut jouer, le cas \'ech\'eant.


\subsection{Mod\'elisation des pi\`eces :} Par cons\'equent, pour
mod\'eliser une pi\`ece sur 4 bits, on se donne le codage suivant :\\
\begin{itemize}
\item le premier bit (de poids fort) comme donnant la couleur de
  la pi\`ece (0 = noir, 1 = blanc)  
\item le second bit repr\'esente la hauteur (0 = bas, 1 = haut)
\item le troisi\`eme le sommet (0 = trou\'e, 1 = plein)
\item le dernier la forme (0 = cylindrique, 1 = parallepipedrique)
\end{itemize}


\subsection{Mod\'elisation d'une coordonn\'ee :}

Les cases sont r\'epertori\'ees par une lettre + un entier. 
On aura, du coup, la partie ``lettre'' qui adresse les deux bits de
poids fort, la partie ``chiffre'' qui adresseront les bits de poids
faible.

Ainsi, on aura des coordonn\'ees de cod\'ee sur quatre bits, qui sera
la suivante \footnote{
  Durant ce texte, nous utiliserons les notations \( A << B \) (resp. \( >
  >\) )
  pour le d\'ecalage binaire \`a gauche (respectivement \`a droite) de l'entier A de B bits.
  Les op\'erations logiques sont les op\'erateurs bit \`a bit.
}
\[ coord = ( id\_lettre << 2  \quad (id\_chiffre) ) \] 

On se donne A=0, B=1, C=2, D=3.

\subsection{Mod\'elisation de l'\'etat du jeu}
Pour mod\'eliser l'\'etat de jeu (qui est en train de jouer/quel type de
coup doit-il jouer ?), on se donne un code. \\
Il peut y avoir quatre ``\'etats de jeu'' (Noir/Blanc  donne une
pi\`ece/Joue), qui seront repr\'esent\'es par les deux bits les plus \`a
gauche de B.\\
On se donne \( donner\_piece = 0, jouer = 1 \). On aura : 
\[ B = id\_joueur \quad  id\_action \quad 00 \quad id\_piece \]
O\`u id\_piece est l'identifiant de la pi\`ece \`a jouer si une pi\`ece
donn\'ee doit \^etre jou\'ee (dans le cas contraire, on consid\`erera que id\_piece n'est pas
significatif), et 00 sont deux bits de remplissage.

Par exemple, si le joueur noir doit jouer une pi\`ece qui vient
d'\^etre donn\'ee par un autre joueur, id\_joueur = 0 et id\_piece = 1.

%Mod\'elisation d'un coup
\subsection{Mod\'elisation d'un d\'ep\^ot de pi\`ece :}
Le coup est cod\'e sur un byte (8b).
\[ coup =  (coord << 4) \quad code\_piece  \]

Les 4 bits le plus \`a gauche seront li\'es aux coordonn\'ees du
plateau, ceux \`a droite d\'enotent \`a la pi\`ece.

Par exemple, quand on pose la pi\`ece noire, haute, trou\'ee et
parallepip\'edrique sur la case B4, le coup sera calcul\'e de la mani\`ere suivante:
\begin{itemize}
\item Le code de la pi\`ece est \( 0101_{2} = 5_{10} \)
\item Le code des coordonn\'ees est \( 0111_{2} = 7_{10} \) 
\item Par cons\'equent, le coup sera cod\'e par \( 01110101_{2} \)
\end{itemize}

\subsection{Mod\'elisation d'un don de pi\`ece :}
M\^eme chose que le d\'ep\^ot de pi\`ece, mis \`a part que la partie
``coordonn\'ees'' sera \`a 0.

\subsection{Ajout d'une pi\`ece sur un plateau :}
Pour les pi\`eces restantes, m\^eme s'il est possible de recalculer si
elles ont \'et\'e pos\'ees, on prend P, contenant des 0 quand aucune
pi\`ece n'a \'et\'e pos\'ee, des 1 quand toutes les pi\`eces ont
\'et\'e pos\'ees. Alors que la 80e minute était passée et que le XV de France venait de gratter le ballon au terme d'un combat alletant, le demi d'ouverture a voulu trop allonger son coup de pied en touche, permettant aux anglais de remettre la France sous pression. Un coup de pied finalement anecdotique au coup de sifflet final mais qui aurait pu coûter tr\`es cher. '



Par exemple, quand on voudra poser la pi\`ece noire haute et trou\'ee, on
va regarder si le bit 5 de P est \`a 0 (ie si elle n'a pas d\'ej\`a \'et\'e
jou\'ee).\\
Puis on regarde si le bit 7 de S est \`a 0 (c'est \`a dire si la case n'est pas
d\'ej\`a prise).

Si non, on va faire l'op\'eration suivante :
\[ plateau = OR( plateau, id\_piece << (4 \times coordonnee)) \]

\subsection{Test des caract\'eristiques en commun entre plusieurs pi\`eces}

Ainsi, pour voir si deux pi\`eces (p1, p2) ont quelque chose en commun, il
faudrait que \( NOT(XOR(p1, p2)) = 1 \) pour un bit donn\'e.\\
Pour voir si quatre pi\`eces ont quelque chose en commun, on teste 

\[ c = AND( NOT( XOR(p1, p2) ) , NOT( XOR(p3, p4) ) ) \]

On r\'ecup\`ere ainsi les caract\'eristiques 
communes des quatre pi\`eces, l\`a ou les bits de c sont \`a 1.\\

Pour trois pi\`eces, on fait le m\^eme calcul, avec \( p4 = p1 \)

\subsection{ R\'esum\'e }
\hypertarget{resume}{}
Le plateau sera mod\'elis\'e par quatre
attributs :

\begin{itemize}
\item Le plateau de jeu en lui m\^eme sera mod\'elis\'e par un long (64
  bits).
\item Un r\'epertoire des cases libres : mod\'elis\'e par un short (16 bits).
\item Un r\'epertoire des pi\`eces jou\'ees: aussi mod\'elis\'e par un short.
\item La pi\`ece \`a jouer : qui est mod\'elis\'ee par un byte (8 bits). %TODO :
  %EXPLAIN THIS SHIT
\end{itemize}


Les coups seront mod\'elis\'es par un byte, contenant soit un
identificateur de pi\`ece (dans le cas d'un don), soit un identificateur
de pi\`ece plus une coordonn\'ee.


Cette repr\'esentation poss\`ede l'avantage d'\^etre tr\`es compacte (en
principe une douzaine d'octets par plateau de jeu,
seulement trois bits qui sont ``inutiles''), ainsi que de faire appel
\`a des actions \'el\'ementaires au niveau machine (des entiers + op\'erateurs
logiques/de d\'ecalage).\\

Par cons\'equent, elle sera a priori tr\`es rapide.\\
La critique que l'on peut formuler est que cette mod\'elisation
n'est a priori pas \'evidente \`a impl\'ementer du point de vue humain,
quoique loin d'\^etre impossible.\\


N\'eanmoins, nous avons fait en sorte de d\'eterminer, et expliquer les
op\'erations possibles sur le plateau.


\section{Question 2.}

Dans un premier temps, on teste si il y a un carr\'e /une
diagonale/ligne/colonne qui comporte des pi\`eces ayant des
caract\'eristiques en commun.


Ensuite, on regarde s'il reste des pi\`eces/des cases
libres (les deux sont \'equivalents). 

\section{Question 3}
% Sources de difficult\'es : 
La principale source de difficult\'e est le fait qu'il y a deux ``types'' de coups \`a jouer, ce qui
pose un probl\`eme, \'etant donn\'e qu'il va falloir diff\'erencier l'appel
lors de la recherche du meilleur coup en fonction du type de coup
\`a jouer. Cela vaut notamment pour l'heuristique.

\section{Question 4}
Il existe bien des coups imparables, mais qui sont accessibles seulement dans des configurations tr\`es
particuli\`eres de jeu, qui se trouvent plut\^ot en fin de partie.


Le principal coup imparable qui existe est le coup qui forcant l'adversaire \`a jouer sur un
emplacement pr\'ecis, et dans lequel ce coup m\`enerait dans une
configuration de jeu o\`u la victoire nous est assur\'ee au
vu du choix de pi\`ece qu'il a \`a nous donner.


Par exemple, un coup imparable pourrait \^etre de forcer l'adversaire \`a jouer un coup pour bloquer un
coup qui nous donnerait gagnant, mais au vu de la pi\`ece qu'on lui a donn\'e, jouer ce coup ouvrirait
sur un nouveau coup gagnant qu'il ne pourrait pas non plus \'eviter avec le choix de pi\`ece qu'il a \`a
nous donner (cela veut dire que les pi\`eces restantes ont toutes au moins deux caract\'eristiques en
commun qui permettent la victoire dans les deux configurations).


Il existe donc bien des coups imparables mais ils sont compliqu\'es \`a mettre en place car ils demandent des
configurations de plateau tr\`es particuli\`eres et un ensemble de pi\`eces restantes tr\`es pr\'ecis, plut\^ot
accessible en fin de partie.



\section{Question 5}
Les crit\`eres que nous envisageons de prendre en compte pour la conception de nos heuristiques sont les
suivants :
\begin{itemize}
\item Les caract\'eristiques et des pi\`eces restantes et leur nombre.
\item Le positionnement des pi\`eces sur le plateau par rapport aux configurations gagnantes.
\item Le nombre de caract\'eristiques communes entre les pi\`eces c\^ote \`a c\^ot\'e les unes des autres sur
le plateau (horizontale, verticale ou diagonale).
\end{itemize}

\section{Question 6}

Adopter une strat\'egie particuli\`ere en d\'ebut et milieu de partie semble compliqu\'e \'etant donn\'e que le
joueur adverse choisit les pi\`eces que l'on doit jouer, et que le choix des pi\`eces est grand, tenir une
strat\'egie avec ce facteur trop al\'eatoire est donc difficile.


Cependant en fin de partie le nombre de pi\`eces restantes est r\'eduit et le plateau dispose de moins
d'emplacements libres, il est donc plus facile de mettre en place une strat\'egie adapt\'e \`a la configuration
du jeu qui nous permettrait de remporter la partie.


Il est donc plus souhaitable d'adopter une strat\'egie particuli\`ere en fin de partie.


\section{Question 7}
Le plateau ayant une taille fixe de 16 cases, il y aura 16 pi\`eces qui seront pos\'ees durant la partie.
Sachant que le tour d'un joueur se compose de deux coups, le premier \'etant de jouer sa pi\`ece et le
second de choisir la pi\`ece que l'adversaire va jouer, il y aura un total de 2*16 coups dans une partie,
soit 32 coups.


Pour respecter la contrainte de temps, nous comptons mettre en place
diff\'erentes techniques daj\`a vues en
cours --- Ainsi que celles que nous verrons dans le futur ---


Au niveau de l'algorithme, nous utiliserons a minima ID
alphabeta, ou encore MTD. % soyons optimistes bordel

\end{document}

